输入系统和事件系统

InputDevice
包括鼠标，键盘，多点触摸屏，重力感应器，游戏手柄等
这些设备在各个平台下，有不同的情况和组合（见下面的输入系统）
这些设备，通过平台的API获得更新，他们包含了不同的数据，比如鼠标有当前点，是否按下哪个键。所以这些设备是完全不相关的，体现在接口上，没有多少共同点。

InputSystem
输入系统是某个平台下面的输入功能的实现者，他包括了该平台下面的所有输入设备，比如Win32可以有键盘鼠标手柄，iPhone有触摸屏和重力感应器，PSP只有游戏手柄。
输入系统对内和Device紧密连接（从系统API那儿获得更新），对于引擎其他部分，InputSystem使用事件机制，这些事件来自与各种输入设备。
之所以不把输入系统的功能直接放在device上，是为了让相关的代码在一起，并且避免Device拥有太多的职责。

Event
事件主要是各种输入事件（每种InputDevice会产生特定的事件），还有GUI事件（如果有GUI系统的话），用户自定义事件等
事件是一个统一的结构，有事件类型和事件数据，事件数据是个unit,他共生了所有可能的事件（irrlicht的设计）
除了用户事件，其他事件都是预先定义好的（无法扩展，除非改代码），而用户事件也只是提供了几个保留参数。
（嗯，这种结构倒也实用，如果考虑扩展，反而得不偿失了）

IEventReceiver
唯一的功能是接收事件，onEvent。只要实现这个接口，并且让InputSystem把自己注册上去，就可以接收到事件了。（可以指定自己接收事件的类型，不过也无所谓，自己不处理的事件直接忽略也可以）

输入系统使用的一种例子:
让App类实现IEventReceiver
InputSystem是在游戏逻辑之前更新，所以发出的事件，本帧收到，App通过onEvent收到事件后，可以记录下来（以备在游戏状态中查询），这样在游戏逻辑中可以用诸如isKeyPressed之类的方法查询（这是为了避免将逻辑代码写到onEvent中）
FLT有可能预先提供这样一套机制，方便具体的游戏使用。

 
根据特定的游戏类型，封装几个经典的输入系统
比如RPG，在此基础封装统一的接口，可以保证游戏在不同的平台上，也是同样的接口，保证代码的清晰性
  

（粗略的想法，欢迎补充）
